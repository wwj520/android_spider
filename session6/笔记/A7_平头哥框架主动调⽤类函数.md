## 使⽤Java反射完成对类函数的调⽤
#### 总结：java主动调用一般流程

- 静态函数调用
```jupyter
   第一：动态获取类对象
           加载类： Class<?> 类对象 = lpparam.classLoader.loadClass("com.xxx.xx")
   第二： 主动获取方法
         Method staticMethod = 类对象.getDeclaredMethod("staticMethod", String.class, int.class);
         staticMethod.setAccessible(true);
   第三： invoke
          staticMethod.invoke(类对象, object args);

```

- 实例函数、jni 函数、内部类调用
```text
    第一：动态获取类对象
           加载类： Class<?> 类对象 = lpparam.classLoader.loadClass("com.xxx.xx")
    第二：获取构造函数 生成实例对象
         2.1 调用无参构造函数
               Object instance =  类对象.newInstance()
         
         2.2 调用有参构造函数
             Constructor<?> constructor = 类对象.getDeclaredConstructor(”方法名“,参数对象...)
             Object instance对象 = constructor.newInstance()
             
    第三： 主动获取方法
          Method method对象= 类对象.getDeclaredMethod(方法名，String.class, int.class)
          Object result = method对象.invoke(instance对象, 实参)
```
 
- 代码demo
     
     
     D:\AndroidStudioProjects\ratel01\app\src\main\java\com\example\ratel01\HookMysterBox7_1_javazhudongdiaoyong.java
```jupyter
package com.example.ratel01;

import android.util.Log;

import com.virjar.ratel.api.rposed.IRposedHookLoadPackage;
import com.virjar.ratel.api.rposed.callbacks.RC_LoadPackage;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

/*

    java主动调用一般流程：第二&第三顺序无所谓
        第一：动态获取类对象
            加载类： Class<?> 类对象 = lpparam.classLoader.loadClass
        第二：获取构造函数 生成实例对象
             Constructor<?> constructor = 类对象.getDeclaredConstructor(”方法名“,参数对象...)、
             Object instance = constructor.newInstance()
        第三： 主动获取方法
              Method method对象= 类对象.getDeclaredMethod()
              Object 结果 method对象.invoke(实例对象, 实参)
*/

public class HookMysterBox7_1_javazhudongdiaoyong implements IRposedHookLoadPackage {
    private static final String TAG = "yuanrenxue--->";


    @Override
    public void handleLoadPackage(RC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
        if ("com.example.mysterbox".equals(lpparam.packageName)){
            Log.d(TAG, "handleLoadPackage: hook success");

            // 1.使⽤Java反射完成对类函数的调⽤
            // 1.1 静态函数主动调用：public static String staticMethod(String name, int price)
            Class<?> loadClass = lpparam.classLoader.loadClass("com.example.mysterbox.MysterBox1");
            Method staticMethod = loadClass.getDeclaredMethod("staticMethod", String.class, int.class);
            staticMethod.setAccessible(true);
            Object result = staticMethod.invoke(loadClass, "jack", 1000);
            Log.d(TAG, "staticMethod-result: " +result);

            // 1.2 实例函数主动调用：public static String staticMethod(String name, int price)
            // 对实例函数调用，不能只拿到class实例，还要拿到class具体实例：既通过newInstance默认调用无参的构造函数,见如下代码
            // -调用无参数的构造函数
            Object instance = loadClass.newInstance();
            Method instanceMethod = loadClass.getDeclaredMethod("instanceMethod", String.class, int.class);
            Object result2 = instanceMethod.invoke(instance, "jack-2", 2000);
            Log.d(TAG, "instanceMethod-result: " +result2);

            // - 调用有参数的构造函数：getDeclaredConstructor(参数类型)
            // private MysterBox1(String brand)
            Constructor<?> constructor = loadClass.getDeclaredConstructor(String.class);
            constructor.setAccessible(true); // 私有构造函数需要加setAccessible
            Object instance1 = constructor.newInstance("测试");
            Log.d(TAG, "handleLoadPackage: 实例" + instance1);
            Object result3 = instanceMethod.invoke(instance1, "JACK-3", 3000);
            Log.d(TAG, "instanceMethod-JACK-3: " +result3);

            // 1.3 内部类的处理
            Class<?> classInnerClass = lpparam.classLoader.loadClass("com.example.mysterbox.MysterBox1$InnerClass");
            Method innerClassMethod = classInnerClass.getDeclaredMethod("innerClassMethod", String.class, int.class);
            innerClassMethod.setAccessible(true);
            Constructor<?> constructor1 = classInnerClass.getDeclaredConstructor();
            constructor1.setAccessible(true);
            Object instance2 = constructor1.newInstance();
            Object result4 = innerClassMethod.invoke(instance2, "jack4", 4000);
            Log.d(TAG, "innerClassMethod: jack4" + result4);


            // 1.4 对JNI函数处理，一般流程
            /*
            在Hook Native方法时，通常使用getConstructor而不是getDeclaredConstructor来获取类对象的原因是：
            1. Native方法通常是在Java类的外部实现的，而不是在Java类内部声明的。因此，使用getDeclaredConstructor无法获取到Native方法的构造函数，因为它只能获取当前类内部声明的构造函数。
            2. Native方法通常是在JNI层实现的，与Java层的类对象没有直接的关联。因此，使用getConstructor可以获取到Java类的公共构造函数，而不需要关注JNI层的实现细节。
            3. Native方法的调用通常是通过JNI接口进行的，而不是通过Java反射机制。因此，在Hook Native方法时，更常见的做法是直接通过JNI接口调用Native方法，而不是通过Java反射机制来获取类对象和构造函数。
            综上所述，Hook Native方法时，通常不需要使用getDeclaredConstructor来获取类对象，而是直接通过JNI接口调用Native方法。如果需要获取类对象，可以使用getConstructor来获取Java类的公共构造函数。*/
            Class<?> classMainActivity = lpparam.classLoader.loadClass("com.example.mysterbox.MainActivity");

            Constructor<?> constructor2 = classMainActivity.getConstructor();
            constructor2.setAccessible(true);
            Object instance3 = constructor2.newInstance();

            Method nativeMethod = classMainActivity.getDeclaredMethod("nativeMethod");
            nativeMethod.setAccessible(true);
            Object result5 = nativeMethod.invoke(instance3);
            Log.d(TAG, "nativeMethod: " + result5);

        }

    }
}






```    



## 使⽤Ratel Api 完成对于类函数的调⽤
#### 总结：Ratel Api主动调用一般流程


    D:\AndroidStudioProjects\ratel01\app\src\main\java\com\example\ratel01\HookMysterBox7_2_ratelApi_diaoyong.java

- 主要方法
```jupyter
      RposedHelpers.callStaticMethod  // public static Object callStaticMethod(Class<?> clazz, String methodName, Object... args)
      
      RposedHelpers.newInstance(loadClass); // newInstance(Class, Object...)
            
      RposedHelpers.callMethod(instance, "instanceMethod", "jack3", 300) // public static Object callMethod(Object obj, String methodName, Object... args)
      
      RposedHelpers.findClass   // public static Class<?> findClass(String className, ClassLoader classLoader)

```
    
    

- 静态函数调用:callStaticMethod
```jupyter
    Class<?> loadClass = lpparam.classLoader.loadClass("com.example.mysterbox.MysterBox1");
    Object result1 = RposedHelpers.callStaticMethod(loadClass, "staticMethod", "JACLK-1", 100);
    Log.d(TAG, "staticMethod: " + result1);
```

- 实例函数、jni 函数、内部类调用
```jupyter
            //1.2  public static Object callStaticMethod(Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)
            Object result2 = RposedHelpers.callStaticMethod(loadClass, "staticMethod", new Class<?>[]{String.class, int.class}, "JACK-2", 200);
            Log.d(TAG, "staticMethod2 " + result2);

            //2. 实例函数的调用：同样需要Java反射拿到实例
            // 2.1 无参构造函数 只需要 public static Object newInstance(Class<?> clazz, Object... args)
            Object instance = RposedHelpers.newInstance(loadClass);
            // public static Object callMethod(Object obj, String methodName, Object... args)
            Object result3 = RposedHelpers.callMethod(instance, "instanceMethod", "jack3", 300);
            Log.d(TAG, "instanceMethod " + result3);

            // 2.2 有参构造函数
            Object instance1 = RposedHelpers.newInstance(loadClass, "brand_kobi");


            // 3. 内部类的处理
            Class<?> InnerClass = RposedHelpers.findClass("com.example.mysterbox.MysterBox1$InnerClass", lpparam.classLoader);
            Object instance2 = RposedHelpers.newInstance(InnerClass);
            Object result4 = RposedHelpers.callMethod(instance2, "innerClassMethod", "jack4", 400);
            Log.d(TAG, "innerClassMethod " + result4);

            // 4. jni 函数调用
            Class<?> mainActivity = RposedHelpers.findClass("com.example.mysterbox.MainActivity", lpparam.classLoader);
            Object instance3 = RposedHelpers.newInstance(mainActivity);
            Object result5 = RposedHelpers.callMethod(instance3, "nativeMethod");
            Log.d(TAG, "nativeMethod " + result5);


```
